#!/usr/bin/env bash
#
#   O         ,-
#  ° o    . -´  '     ,-
#   °  .´        ` . ´,´
#     ( °   ))     . (
#      `-;_    . -´ `.`.
#          `._'       ´
#
# Copyright (c) 2006,2011,2012 Markus Fisch <mf@markusfisch.de>
#
# Licensed under the MIT license:
# http://www.opensource.org/licenses/mit-license.php
#
# @version 1.4.0
#

# Send request and read succeeding response
#
# @param 1 - some request
pop_request()
{
	echo "$1" >&6
	read RESPONSE <&6

	[[ $RESPONSE == -ERR* ]] && {
		echo "error:" ${RESPONSE#*-ERR}
		return 1
	}

	return 0
}

# Logout and close connection to pop box
pop_close()
{
	pop_request 'QUIT'

	exec 6<&-
	exec 6>&-
}

# Open connection to pop box and login
pop_open()
{
	exec 6<>/dev/tcp/$POP_HOST/$POP_PORT ||
		return 1

	local RESPONSE
	read RESPONSE <&6

	[[ $RESPONSE == +OK* ]] &&
		pop_request "USER $POP_ACCOUNT" &&
		pop_request "PASS $POP_PASSWORD" &&
		return 0

	pop_close

	echo 'error: authentification failed!'
	return 1
}

# Decode quoted-printable-encoded stream
decode_quoted_printable()
{
	local IFS= T= CODE= ENCODED=0

	while read -r -n 1 -d $CR C
	do
		[ "$C" == '=' ] &&
			ENCODED=2 &&
			CODE="" &&
			continue

		(( ! $ENCODED )) &&
			T=$T$C &&
			continue

		CODE=$CODE$C
		(( --ENCODED ))

		(( ! $ENCODED )) &&
			eval "C=\$'\\x$CODE'" &&
			T=$T$C
	done

	echo $T
}

# Return current mailbox status in STATUS, MAILS and SIZE
status()
{
	local RESPONSE=

	pop_open || return 1
	pop_request 'STAT' || {
		pop_close
		return 1
	}

	read -d $CR STATUS MAILS SIZE <<EOF
$RESPONSE
EOF

	pop_close
}

# Echo trimmed value of given MIME header field
header_value()
{
	echo ${RESPONSE#*:}
}

# Parse multipart header field
parse_multipart_header_field()
{
	if [ ${RESPONSE:0:1} == $'\t' ]
	then
		RESPONSE=$LAST_MIME_HEADER':'$RESPONSE
	else
		LAST_MIME_HEADER=${RESPONSE%%:*}
	fi

	case "$RESPONSE" in
		[Cc]ontent-[Tt]ype:*)
			TYPE=$TYPE${TYPE:+ }`header_value`
			;;
		[Cc]ontent-[Tt]ransfer-[Ee]ncoding:*)
			ENCODING=$ENCODING${ENCODING:+ }`header_value`
			;;
	esac
}

# Parse a MIME header field
parse_header_field()
{
	case "$RESPONSE" in
		.)
			return 1
			;;
		[Ff][Rr][Oo][Mm]:*)
			FROM=`header_value`
			;;
		[Tt][Oo]:*)
			TO=`header_value`
			;;
		[Ss][Uu][Bb][Jj][Ee][Cc][Tt]:*)
			SUBJECT=`header_value`
			;;
		[Dd][Aa][Tt][Ee]:*)
			DATE=`header_value`
			;;
		[Cc]ontent-*)
			parse_multipart_header_field
			;;
	esac
}

# List message(s)
#
# @param 1 - list of index numbers or "NEW" to list only new messages
list_messages()
{
	local RESPONSE= NEW= MESSAGES=

	if [ "$1" == 'NEW' ]; then
		NEW=1
	else
		MESSAGES="$1"
	fi

	pop_open || return
	pop_request 'UIDL' || {
		pop_close
		return
	}

	local IDS=[] MAILS=
	local N ID

	# download list of messages
	while read -d $CR N ID <&6
	do
		[[ $N == . ]] && break

		[ "$ID" ] || continue

		MAILS="$MAILS $N"
		IDS[$N]="$ID"
	done
	
	# remove last LF
	read <&6

	local MAILBOX=[]
	touch "$CACHE"

	[ "$MESSAGES" ] && MAILS="$MESSAGES"

	# display list of messages
	for N in $MAILS
	do
		local RECORD="`grep "^${IDS[$N]}" "$CACHE"`"
		local FROM= TO= SUBJECT= DATE= ENCODING=
		local D

		if [ "$RECORD" ]; then
			IFS='|' read D D FROM SUBJECT DATE <<EOF
$RECORD
EOF

			MAILBOX[$N]="$RECORD"
		else
			pop_request "TOP $N 0" || break

			while read -d $CR RESPONSE <&6
			do
				parse_header_field || break
			done

			# remove last LF
			read <&6

			MAILBOX[$N]="${IDS[$N]}|0|$FROM|$SUBJECT|$DATE"
		fi

		# skip message if it is in the cache already and NEW is set
		[ "$NEW" ] && [ "$RECORD" ] && continue

		printf "%4d: %s\n      %s\n      %s\n\n" \
			$N \
			"${FROM:0:72}" \
			"$DATE" \
			"${SUBJECT:0:72}"
	done

	pop_close

	# remove cache to get rid of messages that are no longer available
	[ "$MESSAGES" ] || rm "$CACHE"

	for (( N=${#MAILBOX[*]}; $N; --N ))
	do
		# when not rebuild, check for existence first
		[ "$MESSAGES" ] &&
			grep "^${IDS[$N]}|" "$CACHE" &> /dev/null &&
			continue

		# skip empty sets
		[ "${MAILBOX[$N]}" ] || continue

		echo "${MAILBOX[$N]}" >> "$CACHE"
	done
}

# Display a message
#
# @param 1 - message to list
read_message()
{
	local RESPONSE MESSAGE="$1"

	[ "$MESSAGE" ] || return

	pop_open || return

	# get message id and confirm existence
	pop_request "UIDL $MESSAGE" || {
		pop_close
		return
	}

	local OK N ID
	read -d $CR OK N ID <<EOF
$RESPONSE
EOF

	[ "$ID" ] || exit

	pop_request "TOP $MESSAGE $LINES_VIEW" || {
		pop_close
		return
	}

	local FROM= TO= SUBJECT= DATE= ENCODING= BODY=
	local HEADER=true

	while read -d $CR RESPONSE <&6
	do
		[[ $RESPONSE == . ]] && break

		[ "$RESPONSE" ] || HEADER=

		if [ "$HEADER" ]
		then
			parse_header_field
		else
			BODY=$BODY$RESPONSE$LF
		fi
	done

	# remove last LF
	read <&6

	# mark message as read
	if ! [ -f "$CACHE" ] ||
		! grep "^$ID|" "$CACHE" &> /dev/null; then
		echo "$ID|1|$FROM|$SUBJECT|$DATE" >> "$CACHE"
	else
	(
		local CACHECONTENT=`< $CACHE`
		local MID READ
		local FROM TO SUBJECT DATE ENCODING BODY

		rm "$CACHE"

		while IFS='|' read MID READ FROM SUBJECT DATE
		do
			[ $MID == $ID ] &&
				READ=1

			echo "$MID|$READ|$FROM|$SUBJECT|$DATE" >> "$CACHE"
		done <<EOF
$CACHECONTENT
EOF
	)
	fi

	pop_close

	[[ $ENCODING == *quoted-printable* ]] &&
		BODY=`echo $BODY | decode_quoted_printable`

	less <<EOF
`printf "%-8s: %s\n" "From" "$FROM"`
`printf "%-8s: %s\n" "To" "$TO"`
`printf "%-8s: %s\n" "Subject" "$SUBJECT"`
`printf "%-8s: %s\n" "Date" "$DATE"`

`echo "$BODY"`
EOF
}

# Read next new message
read_next_message()
{
	local RESPONSE

	# if no cache file exists try to display first message
	[ -f "$CACHE" ] || {
		status || return
		read_message 1

		return
	}

	pop_open || return
	pop_request 'UIDL' || {
		pop_close
		return
	}

	local NEXT=0 N ID

	# find first unread
	while read -d $CR N ID <&6
	do
		[[ $N == . ]] && break

		[ "$ID" ] || continue

		(( $NEXT )) ||
			grep "^$ID|1|" "$CACHE" &> /dev/null ||
			NEXT=$N
	done

	# remove last LF
	read <&6

	pop_close

	(( $NEXT )) &&
		read_message $NEXT
}

# Check for new messages and set NEW_MAILS accordingly
new_messages()
{
	local RESPONSE

	pop_open || return 1
	pop_request 'UIDL' || {
		pop_close
		return 1
	}

	NEW_MAILS=0

	local N ID
	while read -d $CR N ID <&6
	do
		[[ $N == . ]] && break

		[ "$ID" ] || continue

		if ! [ -f $CACHE ] ||
			! grep "^$ID" "$CACHE" &> /dev/null; then
			(( NEW_MAILS++ ))
		fi
	done

	# remove last LF
	read <&6

	pop_close
}

# Download message to disk
#
# @param 1 - index of message to file
file_message()
{
	local RESPONSE

	[ "$1" ] || return

	pop_open || return
	pop_request "RETR $1" || {
		pop_close
		return
	}

	local FILE="${BIN}-message"
	local FROM= TO= SUBJECT= DATE= ENCODING=
	local HEADER=true

	while IFS=$LF read -d $CR RESPONSE <&6
	do
		[[ $RESPONSE == . ]] && break

		[ "$RESPONSE" ] || HEADER=

		[ "$HEADER" ] &&
			parse_header_field

		echo "$RESPONSE" >> "$FILE"
	done

	pop_close

	[ "$DATE" ] ||
		DATE=`date +%Y%m%d%H%M%S`

	FROM=${FROM#*<}
	FROM=`echo ${FROM%>*}`

	[ "$FROM" ] && [ -f "$FILE" ] &&
		mv "$FILE" "$FROM-$DATE"
}

# Delete messages from server
#
# @param 1 - list of indices of messages to delete (optional)
delete_messages()
{
	local MESSAGES="$1"

	[ "$MESSAGES" ] || {
		status || return

		for (( N=1; $N <= $MAILS; N++ ))
		do
			MESSAGES="$N $MESSAGES"
		done
	}

	pop_open || return

	local RESPONSE N
	for N in $MESSAGES
	do
		pop_request "DELE $N" || break
	done

	pop_close
}

# Base64 en-/decoder, this is a fallback for systems that lack base64
#
# @param ... - flags
which base64 &>/dev/null ||	base64()
{
	local SET='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	local DECODE F

	for F in $@
	do
		case "$F" in
			-d)
				DECODE=1
				;;
		esac
	done

	(( DECODE )) && {
		local N=0 V=0 C

		IFS=
		while read -d '' -r -n1 C
		do
			[ $C == $'\n' ] && continue

			if [ $C == '=' ]
			then
				V=$(( V << 6 ))
			else
				local P

				if [ $C == '+' ]
				then
					P=`expr index "$SET" "\+"`
				else
					P=`expr index "$SET" $C`
				fi

				V=$(( V << 6 | --P ))
			fi

			(( ++N == 4 )) && {
				local S

				for (( B=3, S=16; B--; S-=8 ))
				do
					printf \\$( printf '%03o' $(( V >> S & 255 )))
				done

				V=0
				N=0
			}
		done

		return
	}

	local V=0
	local W=0
	local SH=16
	local X
	local EOF=0
	local M=4

	IFS=
	while true
	do
		(( EOF )) ||
			read -d '' -r -n1 X || {
			EOF=1

			if (( SH == 8 ))
			then
				M=2
			elif (( SH == 0 ))
			then
				M=3
			else
				break
			fi
		}

		local C=0

		(( EOF )) ||
			case "$X" in
				'')
					C=0
					;;
				*)
					C=`printf '%d' "'$X"`
					;;
			esac

		V=$(( C << SH | V ))
		(( SH -= 8 ))

		(( SH < 0 )) && {
			local B
			local S

			for (( B=0, S=18; B<M; ++B, S-=6 ))
			do
				local C=$(( V >> S & 63 ))

				echo -n ${SET:$C:1}

				(( ++W > 75 )) && {
					echo
					W=0
				}
			done

			for (( B=0, MM=4-M; B<MM; ++B ))
			do
				echo -n "="
			done

			(( EOF )) && break

			SH=16
			V=0
		}
	done
}

# Send request and read succeeding response
#
# @param 1 - some command
smtp_request()
{
	local RESPONSE

	echo "$1" >&7

	for (( ;; ))
	do
		read RESPONSE <&7

		[ "${RESPONSE:3:1}" != "-" ] && break
	done

	[[ $RESPONSE == [23]* ]] || {
		echo "error: $RESPONSE"
		return 1
	}

	return 0
}

# Close connection to smtp server and log off
smtp_close()
{
	smtp_request 'QUIT'

	exec 7<&-
	exec 7>&-
}

# Open connection to smtp server and log on
smtp_open()
{
	exec 7<>/dev/tcp/$SMTP_HOST/$SMTP_PORT ||
		return 1

	local RESPONSE
	read RESPONSE <&7

	if [ "$SMTP_PASSWORD" ]; then
		smtp_request "EHLO $SMTP_HOST" &&
			smtp_request 'AUTH LOGIN' &&
			smtp_request "`echo -n "$SMTP_ACCOUNT" | base64`" &&
			smtp_request "`echo -n "$SMTP_PASSWORD" | base64`" &&
			return 0
	else
		smtp_request "HELO $SMTP_HOST" && return 0
	fi

	smtp_close

	return 1
}

# Write and send a message
#
# @param 1 - recipient of the message
# @param 2 - subject of the mail (optional)
write_message()
{
	local TO="$1"
	local SUBJECT="$2"
	local BODY=

	[ "$TO" ] && echo "To     : $TO"

	while [ -z "$TO" ]
	do
		printf 'To     : '
		read TO
	done

	local RCPT="$TO"
	local FROM="$SMTP_ACCOUNT"

	if [[ $RCPT == *\<* ]] ; then
		RCPT=${RCPT#*<}
		RCPT=`echo ${RCPT%>*}`
	fi

	if [[ $FROM == *\<* ]] ; then
		FROM=${FROM#*<}
		FROM=`echo ${FROM%>*}`
	fi

	if [ -z "$SUBJECT" ]; then
		printf 'Subject: '
		read SUBJECT
	else
		echo "Subject: $SUBJECT"
	fi

	while [ -z "$BODY" ]
	do
		echo 'Message: (hit CTRL-D when finished)'
		BODY="`cat`"
	done

	smtp_open || return

	smtp_request "MAIL FROM: <$FROM>" &&
		smtp_request "RCPT TO: <$RCPT>" &&
		smtp_request "DATA" &&
		smtp_request "From: $SMTP_ACCOUNT
To: $TO
Subject: $SUBJECT
Date: `export LANG=; date +"%a, %d %b %Y %H:%M:%S %z"`
MIME-Version: 1.0
Content-Type: text/plain;
Content-Transfer-Encoding: 8bit;

`echo "$BODY" | while read -n 76 LINE; do echo "$LINE"; done`
." &&
		smtp_close &&
		return

	echo 'error: message NOT sent!'
	smtp_close
}

# Answer a message
#
# @param 1 - index of message
answer_message()
{
	local RESPONSE N="$1"

	pop_open || return
	pop_request "TOP $N 0" || {
		pop_close
		return
	}

	local FROM= TO= SUBJECT= DATE= ENCODING=

	while read -d $CR RESPONSE <&6
	do
		parse_header_field || break
	done

	# remove last LF
	read <&6

	pop_close

	FROM=${FROM#*<}
	FROM=`echo ${FROM%>*}`

	[ "$FROM" ] || return

	write_message "$FROM" "Re: $SUBJECT"
}

# Ask for a setting and put it into $CONFIG
#
# @param 1 - name of the setting
# @param 2 - question phrase
config_prompt()
{
	local ANSWER= PRESET= DEFAULT=

	eval "DEFAULT=\$$1"

	[ "$DEFAULT" ] && PRESET=" [$DEFAULT]"
	[ "$OPTIONAL" ] && PRESET="$PRESET (optional)"

	while [ -z "$ANSWER" ]
	do
		printf "$2$PRESET: "
		read -e ANSWER

		[ "$ANSWER" ] || {
			[ "$OPTIONAL" ] && return
			[ "$DEFAULT" ] && ANSWER="$DEFAULT"
		}
	done

	[ "$VOLATILE" ] ||
		echo "$1='$ANSWER'" >> "$CONFIG"

	eval "$1=\$ANSWER"
}

# Check configuration
config_check()
{
	[ "$POP_HOST" ] &&
		[ "$POP_ACCOUNT" ] &&
		[ "$SMTP_HOST" ] &&
		[ "$SMTP_ACCOUNT" ] && {
		# ask for passwords and don't save them
		[ -z "$POP_PASSWORD" ] && {
			VOLATILE=true config_prompt POP_PASSWORD 'POP3 password'

			[ -z "$SMTP_PASSWORD" ] &&
				VOLATILE=true OPTIONAL=true config_prompt \
					SMTP_PASSWORD 'SMTP password'

			# clear screen to remove visible password(s)
			clear
		}
		return 0
	}

	if [ -f "$CONFIG" ]; then
		cat <<EOF
Missing settings in $CONFIG!
Do you like to change/complete your configuration now ([yes]/no)
EOF
	else
		cat <<EOF
Missing configuration file! This seems to be the first time you are running
this script. Do you like to set up a configuration now? ([yes]/no)
EOF
	fi

	local ANSWER
	read -e ANSWER

	case "$ANSWER" in
		y*|Y*|"")
			# remove any previous configuration
			[ -f "$CONFIG" ] && rm "$CONFIG"
			;;
		*)
			return 1
			;;
	esac

	config_prompt POP_HOST 'POP3 host'
	config_prompt POP_PORT 'POP3 port'
	config_prompt POP_ACCOUNT 'POP3 account'
	config_prompt POP_PASSWORD 'POP3 password'
	config_prompt SMTP_HOST 'SMTP host'
	config_prompt SMTP_PORT 'SMTP port'
	config_prompt SMTP_ACCOUNT 'SMTP account'
	OPTIONAL=true config_prompt SMTP_PASSWORD 'SMTP password'

	echo 'setup complete.'

	return 0
}

# Validate indices and set INDICES accordingly
#
# @param ... - index numbers
validate_indices()
{
	INDICES=

	# get number of mails
	status || return

	local N

	for N in $@
	do
		[[ $N == [0-9-]* ]] || continue

		local START=${N%-*}
		local STOP=${N#*-}

		# intercept 0 and "" (when skipped)
		if [ -z "$START" ] ||
			(( ! $START )); then
			START=1
		fi

		# intercept 0, "" and check if valid
		if [ -z "$STOP" ] ||
			(( ! "$STOP" )) ||
			(( $STOP > $MAILS )); then
			STOP=$MAILS
		fi

		(( $START == $STOP )) && {
			INDICES=$INDICES$N$LF
			continue
		}

		for (( C=$START; $C <= $STOP; ++C ))
		do
			INDICES=$INDICES$C$LF
		done
	done

	[ $REVERSE ] &&
		INDICES="`echo "$INDICES" | sort -nr`"
}

# Quit background instance
quit_background()
{
	[ -f "$PIDFILE" ] || return

	kill `< "$PIDFILE"` &> /dev/null
	rm -f "$PIDFILE"
}

# Run given command
#
# @param 1 - some command
# @param ... - command arguments
run()
{
	case "$1" in
		h*|\?*)
			cat <<EOF
  p(eek)                 peek for new messages
  P(eek)                 peek continuously & notify on mail
  s(tatus)               request mailbox status
  n(ew)                  list (only) new messages
  l(ist) [N[-N]]...      list messages
  r(ead) [N[-N]]...      read message
  f(ile) N[-N]...        file message to current directory
  d(elete) N[-N]...|all  remove message
  a(nswer) N             answer message
  w(rite) ADDRESS        write a message to ADDRESS
  c(lear)                clear screen
  h(elp)                 show this info
  v(ersion)              show version
  q(uit)                 quit
  Q(uit)                 quit background P(eek) instance
EOF
			;;
		v*)
			local VERSION=`grep "^#[ \t]*@version" $0`
			echo ${VERSION##* }
			;;
		p*)
			new_messages

			echo "$NEW_MAILS new mails"
			;;
		P*)
			if [ -z "$NOTIFICATION" ] || [ -z "$INTERVAL" ]
			then
				echo 'error: missing notification command!'
				return
			fi

			quit_background

			while true
			do
				# this will NOT mark messages as listed, so you need to call
				# "readmail l q" in your notification if you're using this
				# script just to be notified, otherwise this wouldn't really
				# be a "peek" because it changes the cache
				new_messages || break

				# allow a list of commands to be executed
				(( NEW_MAILS > 0 )) &&
					/usr/bin/env bash <<EOF
#!/usr/bin/env bash
$NOTIFICATION
EOF

				sleep $INTERVAL
			done &

			echo "$!" > "$PIDFILE"
			exit
			;;
		s*)
			status

			echo "$MAILS mails ($SIZE bytes)"
			;;
		n*)
			list_messages NEW
			;;
		l*)
			(( $# < 2 )) && {
				list_messages
				return
			}

			shift
			validate_indices $@

			[ "$INDICES" ] &&
				list_messages "$INDICES"
			;;
		d*)
			(( $# < 2 )) && return

			shift
			case $1 in
				all)
					delete_messages
					;;
				*)
					# because the following indices will change after
					# a message is deleted it is very important to
					# sort list reverse
					REVERSE=true validate_indices $@

					[ "$INDICES" ] &&
						delete_messages "$INDICES"
					;;
			esac
			;;
		r*)
			(( $# < 2 )) && {
				read_next_message
				return
			}

			shift
			validate_indices $@

			[ "$INDICES" ] && {
				local N

				for N in $INDICES
				do
					clear
					read_message $N
				done
			}
			;;
		f*)
			shift
			validate_indices $@

			[ "$INDICES" ] && {
				local N

				for N in $INDICES
				do
					file_message $N
				done
			}
			;;
		a*)
			(( $# < 2 )) && return

			shift
			answer_message $1
			;;
		w*)
			shift
			write_message $@
			;;
		c*)
			clear
			;;
		q*|exit)
			exit
			;;
		Q*)
			quit_background
			exit
			;;
		*)
			[ "$1" ] && {
				echo "error: unknown command '$1'"
				return
			}

			read_next_message
			;;
	esac
}

readonly BIN=${0##*/}
readonly CONFIG="$HOME/.${BIN}rc"
readonly CACHE="$HOME/.${BIN}cache"
readonly PIDFILE="$HOME/.${BIN}pid"
readonly CR=$'\r'
readonly LF=$'\n'

# read configuration
[ -r $CONFIG ] && . $CONFIG

POP_PORT=${POP_PORT:-110}
SMTP_PORT=${SMTP_PORT:-25}
INTERVAL=${INTERVAL:-60}
LINES_VIEW=${LINES_VIEW:-256}

config_check || exit 1

# process command line arguments
for CMD in "$@"
do
	run $CMD
done

# interactive operation
while read -p "$POP_ACCOUNT> " -e CMD
do
	run $CMD
done
